1. 构建二叉树
  典型例题：从前序遍历和中序遍历构建二叉树、从前序遍历和中序遍历构建二叉树、从前序遍历和后序遍历构建二叉树（leetcode 105,106,107）
  （1）从前序遍历和中序遍历构建二叉树、从前序遍历和中序遍历构建二叉树
      这两种属于同一种题型，我们从前者来讲解DFS和BFS的应用。
      （递归DFS）首先，我们能从前序遍历第一个获取根节点的信息,(后续遍历最后一个是根节点)；然后，在中序遍历中找到根节点的位置，它的左边就是左子树的节点，右边就是右子树的节点。
      （迭代BFS）首先，建立一个栈和指针辅助二叉树的构造。初始栈中存放了根节点，指针指向中序遍历的第一个节点；然后，依次枚举前序中除了第一个节点以外的每个节点。
      如果index恰好指向栈顶节点，那么我们不断弹出栈顶节点并向右移动index，并将当前节点作为最后一个弹出的节点的右儿子；如果index和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；
      最后，将当前节点入栈。
      （我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（后序遍历的最后一个节点），指针指向中序遍历的最后一个节点；
        依次枚举后序遍历中除了最后一个节点以外的每个节点。如果 index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向左移动 index，并将当前节点作为最后一个弹出的节点的左儿子；
        如果 index 和栈顶节点不同，我们将当前节点作为栈顶节点的右儿子；我们最后都将当前的节点入栈。）
        
  （2）从前序遍历和后序遍历构建二叉树
      思路
      前序遍历为：(根结点) (前序遍历左分支) (前序遍历右分支)
      而后序遍历为：(后序遍历左分支) (后序遍历右分支) (根结点)
      例如，如果最终的二叉树可以被序列化的表述为 [1, 2, 3, 4, 5, 6, 7]，那么其前序遍历为 [1] + [2, 4, 5] + [3, 6, 7]，而后序遍历为 [4, 5, 2] + [6, 7, 3] + [1].
      如果我们知道左分支有多少个结点，我们就可以对这些数组进行分组，并用递归生成树的每个分支。

  算法:
      我们令左分支有 LL 个节点。我们知道左分支的头节点为 pre[1]，但它也出现在左分支的后序表示的最后。所以 pre[1] = post[L-1]（因为结点的值具有唯一性），因此 L = post.indexOf(pre[1]) + 1。
      现在在我们的递归步骤中，左分支由 pre[1 : L+1] 和 post[0 : L] 重新分支，而右分支将由 pre[L+1 : N] 和 post[L : N-1] 重新分支。
      
2.岛屿问题
  典型例题：岛屿数量、岛屿周长、岛屿最大面积、最大人工岛（leetcode 200，463，695， 827）
  
