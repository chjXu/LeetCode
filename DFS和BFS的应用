1. 构建二叉树
  典型例题：从前序遍历和中序遍历构建二叉树、从前序遍历和中序遍历构建二叉树、从前序遍历和后序遍历构建二叉树（leetcode 105,106,107）
  （1）从前序遍历和中序遍历构建二叉树、从前序遍历和中序遍历构建二叉树
      这两种属于同一种题型，我们从前者来讲解DFS和BFS的应用。
      （递归DFS）首先，我们能从前序遍历第一个获取根节点的信息,(后续遍历最后一个是根节点)；然后，在中序遍历中找到根节点的位置，它的左边就是左子树的节点，右边就是右子树的节点。
      （迭代BFS）首先，建立一个栈和指针辅助二叉树的构造。初始栈中存放了根节点，指针指向中序遍历的第一个节点；然后，依次枚举前序中除了第一个节点以外的每个节点。
      如果index恰好指向栈顶节点，那么我们不断弹出栈顶节点并向右移动index，并将当前节点作为最后一个弹出的节点的右儿子；如果index和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；
      最后，将当前节点入栈。
      （我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（后序遍历的最后一个节点），指针指向中序遍历的最后一个节点；
        依次枚举后序遍历中除了最后一个节点以外的每个节点。如果 index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向左移动 index，并将当前节点作为最后一个弹出的节点的左儿子；
        如果 index 和栈顶节点不同，我们将当前节点作为栈顶节点的右儿子；我们最后都将当前的节点入栈。）
        
  （2）从前序遍历和后序遍历构建二叉树
      思路
      前序遍历为：(根结点) (前序遍历左分支) (前序遍历右分支)
      而后序遍历为：(后序遍历左分支) (后序遍历右分支) (根结点)
      例如，如果最终的二叉树可以被序列化的表述为 [1, 2, 3, 4, 5, 6, 7]，那么其前序遍历为 [1] + [2, 4, 5] + [3, 6, 7]，而后序遍历为 [4, 5, 2] + [6, 7, 3] + [1].
      如果我们知道左分支有多少个结点，我们就可以对这些数组进行分组，并用递归生成树的每个分支。

  算法:
      我们令左分支有 LL 个节点。我们知道左分支的头节点为 pre[1]，但它也出现在左分支的后序表示的最后。所以 pre[1] = post[L-1]（因为结点的值具有唯一性），因此 L = post.indexOf(pre[1]) + 1。
      现在在我们的递归步骤中，左分支由 pre[1 : L+1] 和 post[0 : L] 重新分支，而右分支将由 pre[L+1 : N] 和 post[L : N-1] 重新分支。
      
2.岛屿问题
  典型例题：岛屿数量、岛屿周长、岛屿最大面积、最大人工岛（leetcode 200，463，695， 827）
  问题描述：由 m×n 个小方格组成一个网格，每个小方格与其上下左右四个方格认为是相邻的，要在这样的网格上进行某种搜索。岛屿问题是一类典型的网格问题。每个格子中的数字可能是 0 或者 1。
           我们把数字为 0 的格子看成海洋格子，数字为 1 的格子看成陆地格子，这样相邻的陆地格子就连接成一个岛屿。
  
  DFS结构：网格结构要比二叉树结构稍微复杂一些，它其实是一种简化版的图结构。要写好网格上的 DFS 遍历，我们首先要理解二叉树上的 DFS 遍历方法，再类比写出网格结构上的 DFS 遍历。
          首先，网格结构中的格子有多少相邻结点？答案是上下左右四个。对于格子 (r, c) 来说（r 和 c 分别代表行坐标和列坐标），四个相邻的格子分别是 (r-1, c)、(r+1, c)、(r, c-1)、(r, c+1)。
          换句话说，网格结构是「四叉」的。
          其次，网格 DFS 中的 base case 是什么？从二叉树的 base case 对应过来，应该是网格中不需要继续遍历 grid[r][c] 会出现数组下标越界异常的格子，也就是那些超出网格范围的格子。
          这样，我们得到了网格 DFS 遍历的框架代码：
            void dfs(int[][] grid, int r, int c) {
                // 判断 base case
                // 如果坐标 (r, c) 超出了网格范围，直接返回
                if (!inArea(grid, r, c)) {
                    return;
                }
                // 访问上、下、左、右四个相邻结点
                dfs(grid, r - 1, c);
                dfs(grid, r + 1, c);
                dfs(grid, r, c - 1);
                dfs(grid, r, c + 1);
            }

            // 判断坐标 (r, c) 是否在网格中
            boolean inArea(int[][] grid, int r, int c) {
                return 0 <= r && r < grid.length 
                      && 0 <= c && c < grid[0].length;
            }
            
            
   如何避免重复遍历？
        网格结构的 DFS 与二叉树的 DFS 最大的不同之处在于，遍历中可能遇到遍历过的结点。这是因为，网格结构本质上是一个「图」，我们可以把每个格子看成图中的结点，每个结点有向上下左右的四条边。
        在图中遍历时，自然可能遇到重复遍历结点。
        如何避免这样的重复遍历呢？答案是标记已经遍历过的格子。以岛屿问题为例，我们需要在所有值为 1 的陆地格子上做 DFS 遍历。
        每走过一个陆地格子，就把格子的值改为 2，这样当我们遇到 2 的时候，就知道这是遍历过的格子了。
        
        void dfs(int[][] grid, int r, int c) {
              // 判断 base case
              if (!inArea(grid, r, c)) {
                  return;
              }
              // 如果这个格子不是岛屿，直接返回
              if (grid[r][c] != 1) {
                  return;
              }
              grid[r][c] = 2; // 将格子标记为「已遍历过」

              // 访问上、下、左、右四个相邻结点
              dfs(grid, r - 1, c);
              dfs(grid, r + 1, c);
              dfs(grid, r, c - 1);
              dfs(grid, r, c + 1);
          }

          // 判断坐标 (r, c) 是否在网格中
          boolean inArea(int[][] grid, int r, int c) {
              return 0 <= r && r < grid.length 
                    && 0 <= c && c < grid[0].length;
          }


